//id is nullable 34an hoa supposedly autogenerated, doesn't have to be input

import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';

class Note {
  final int? id;
  final String title;
  final String content;
  final DateTime createdAt;

  Note({
    required this.content,
    required this.createdAt,
    this.id,
    required this.title,
  });

  Map<String, Object?> toJson() {
    //na already m3aya el object fl program mesh lazm ab3tu as a parameter.
    return {
      "id": id,
      "content": content,
      "createdAt": createdAt.toIso8601String(),
      // Why use toIso8601String()?
      // SQLite (and JSON in general) doesn’t understand Dart’s DateTime object.
      // toIso8601String() converts it into a standard string format like:
      // 2025-08-16T18:25:43.511Z
      "title": title,
    };
  }

  static Note fromJson(Map<String, Object?> json) {
    return Note(
      id: json["id"] as int?, // nullable since it might be auto-generated
      title: json["title"] as String,
      content: json["content"] as String,
      createdAt: DateTime.parse(json["createdAt"] as String),
    );
  }

  Note copy({
    int? id,
    String? title,
    String? content,
    DateTime? createdAt,
  }) //tab wblnsba llmesh hyt3dl? it should take ba2y ldata ladeema lalready 3ndy w mesh 3yza aghyrha aw al3b feiha
  => Note(
    content: content ?? this.content,
    createdAt: createdAt ?? this.createdAt,
    title: title ?? this.title,
  );
  //copy: btb3t nus5a gdeeda men l note m3 t3deel field aw multiple ones.
}

class NotesDatabase {
  //aft7 db, CRUD, db init
  //singleton 34an mesh kul marra aft7 yft7 db gdeeda, so we end up having a memory leak.
  static final NotesDatabase instance = NotesDatabase._init();
  static Database? _database;
  //law mwguda rag3ha law la, init one
  NotesDatabase._init();
  //what is that aslan? whose constructor and why is it even needed?

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase("notes.db");
    return _database!;
    //lazm mwdu3 l null safety dah
  }

  //m7tag ab3t path 34an a7dd mkan l initialization bta3 l d
  Future<Database> _initDatabase(String filePath) async {
    //1- getting lmkan bta3 lfile
    final dbPath = await getDatabasesPath();
    //2- merging both, l gotten onw wlmb3ut f parameter
    final fullPath = join(dbPath, filePath);
    print('Database path: $fullPath');
    //3- opening the database, after full path merge

    // You're NOT calling _createDB here
    // You're just TELLING openDatabase "use this function IF you need to create tables"

    return await openDatabase(fullPath, version: 1, onCreate: _createDB);

    // ✅ Function reference - let SQLite call it with the right parameters
    //onCreate: _createDB

    // ❌ Function call - you're calling it immediately (wrong!)
    //onCreate: _createDB(db, version)  // Where would db and version even come from?

    // ✅ Anonymous function - manually defining the callback
    //onCreate: (db, version) {
    //return _createDB(db, version);
  }

  Future<void> _createDB(Database db, int version) async {
    await db.execute('''
   CREATE TABLE notes (
   id INTEGER PRIMARY KEY AUTOINCREMENT,
   title TEXT NOT NULL,
   content TEXT NOT NULL,
   createdAt TEXT NOT NULL
   )
   ''');
  }

  Future<Note> createNote(Note note) async {
    final db = await instance.database;
    //3ayzeen nzwd l ID autogenerated fldatabase w yt create mennu nus5a gdeeda
    //function insert btrg3 id aslan
    final id = await db.insert("notes", note.toJson());
    return note.copy(id: id);
  }

  Future<Note> readNote(int id) async {
    final db = await instance.database;
    //btrg3 list kamla, not just one note, bas i need only one note using a unique id
    //by default columns get to choose those you wanna return
    final maps = await db.query(
      "notes",
      columns: ['id', 'title', 'content', 'createdAt'],
      where: 'id = ?', // una2n 3allla eh
      whereArgs: [id], //value
      //whereargs vs where?
    );
    return Note.fromJson(maps.first);
    //kedah kedah l list feiha item wa7ed bas it has to be treated still as a list
  }

  Future<List<Note>> readAllNotes() async {
    final db = await instance.database;
    final result = await db.query('notes', orderBy: "createdAt DESC");
    return result.map((note) => Note.fromJson(note)).toList();
  }

  Future<int> updateNotes(Note note) async {
    final db = await instance.database;
    return db.update(
      "notes",
      note.toJson(),
      where: "id = ?",
      whereArgs: [note.id],
    );
  }

  Future<int> deleteNote(int id) async {
    final db = await instance.database;
    return await db.delete("notes", where: 'id = ?', whereArgs: [id]);
  }

  Future<void> closeDatabase() async {
    final db = await instance.database;
    db.close();
  }
}
