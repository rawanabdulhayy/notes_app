//id is nullable 34an hoa supposedly autogenerated, doesn't have to be input

import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';

class Note {
  final int? id;
  final String title;
  final String content;
  final DateTime createdAt;

  Note({
    required this.content,
    required this.createdAt,
    this.id,
    required this.title,
  });

  Map<String, Object?> toJson() {
    //na already m3aya lobj fl program mesh lazm ab3t paramter
    return {
      "id": id,
      "content": content,
      "createdAt": createdAt.toIso8601String(),
      // Why use toIso8601String()?
      // SQLite (and JSON in general) doesn’t understand Dart’s DateTime object.
      // toIso8601String() converts it into a standard string format like:
      // 2025-08-16T18:25:43.511Z
      "title": title,
    };
  }

  static Note fromJson(Map<String, Object?> json) {
    return Note(
      id: json["id"] as int?, // nullable since it might be auto-generated
      title: json["title"] as String,
      content: json["content"] as String,
      createdAt: DateTime.parse(json["createdAt"] as String),
    );
  }

  Note copy({
    int? id,
    String? title,
    String? content,
    DateTime? createdAt,
  }) //tab wblnsba llmesh hyt3dl? it should take ba2y ldata ladeema lalready 3ndy w mesh 3yza aghrha aw al3b feiha
  => Note(
    content: content ?? this.content,
    createdAt: createdAt ?? this.createdAt,
    title: title ?? this.title,
  );
  //btb3t nus5a gdeeda men l note m3 t3deel field aw aktar
}

class NotesDatabase {
  //aft7 db, CRUD, db init
  //singleton 34an mesh kul marra acft7 yft7 db gdeeda so we have a memory leak
  static final NotesDatabase instance = NotesDatabase._init();
  static Database? _database;
  NotesDatabase._init();
  //what is that aslan? whose constructor and why is it even needed?
  //law mwguda rag3ha law la init one

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase("notes.db");
    return _database!;
    //lazm mwdue l null safety dah
  }

  //m7tag ab3t path 34an a7dd mkan l initialization bta3 l d
  Future<Database> _initDatabase(String filePath) async {
    //1- getting lmkan bta3 lfile
    final dbPath = await getDatabasesPath();
    //2- merging both, l gotten onw wlmb3ut f parameter
    final fullPath = join(dbPath, filePath);
    //3- opening the database, after full path merge
    return await openDatabase(fullPath, version: 1, onCreate: _createDB);
  }

  Future<void> _createDB(Database db, int version) async {
    await db.execute('''
   CREATE TABLE notes (
   id INTEGER PRIMARY KEY AUTOINCREMENT,
   title TEXT NOT NULL,
   content TEXT NOT NULL,
   createdAt TEXT NOT NULL,
   )
   ''');
  }

  Future<Note> createNote(Note note) async {
    final db = await instance.database;
    //3ayzeen nzwd l ID autogenerated fldatabase w yt create mennu nus5a gdeeda
    //function insert btrg3 id aslan
    final id = await db.insert("notes", note.toJson());
    return note.copy(id: id);
  }

  Future<Note> readNote(int id) async {
    final db = await instance.database;
    //btrg3 list kamla, not just one note, bas i need only one note using a unique id
    //by default columns get to choose those you wanna return
    final maps = await db.query(
      "notes",
      columns: ['id', 'title', 'content', 'createdAt'],
      where: 'id = ?', // una2n 3allla eh
      whereArgs: [id], //value
      //whereargs vs where?
    );
    return Note.fromJson(maps.first);
    //kedah kedah l list feiha item wa7ed bas it has to be treated still as a list
  }

  Future<List<Note>> readAllNotes() async {
    final db = await instance.database;
    final result = await db.query('notes', orderBy: "createdAt DESC");
    return result.map((note) => Note.fromJson(note)).toList();
  }

  Future<int> updateNotes(Note note) async {
    final db = await instance.database;
    return db.update(
      "notes",
      note.toJson(),
      where: "id = ?",
      whereArgs: [note.id],
    );
  }

  Future<int> deleteNote(int id) async {
    final db = await instance.database;
    return await db.delete("notes", where: 'id = ?', whereArgs: [id]);
  }

  Future <void> closeDatabase () async {
    final db = await instance.database;
    db.close();
  }
}
